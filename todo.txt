1 - Criação do speech_commands: gerar todas as partições e realizar para cada uma o encode e filter, deixar salvo em
variável e acessar quando cliente selecionado. (ok)
2 - Programar servidor|client base + fedavg. (ok)
3 - Garantir a execução de n_rounds + 1, onde round 1 é apenas para obter mapeamento de cids. Ou usar memória compartilhada
do flower para mapeamento e usar a quantidade de rodadas normal. (ok - há possibilidade com grids, mas mudaria a forma
mais agradável de organizar o código. Portanto, resolvi deixar com está e salvar resultados como rodada-1. Rodada 1 não
faz nada e apenas serve para responder os valores ao servidor, e rodada 2 é encarada como 1 e assim por diante.)
4 - Adicionar consumo de energia e tempo (ok)
5 - Adicionar escolha se usa bateria (ok)
6 - Adicionar calculo/log de métricas (ok)
7 - Adicionar twophasefedavg (ok)
8 - Modificar base para manter modelo global da rodada e atualizar após o aggregate_fit
9 - Criar nova estratégia que calcula a coerência local a partir da diferença de pesos entre locais atualizados e global
10 - Implementar o cálculo de EoS
